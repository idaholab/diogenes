<cfscript>
	/* Dev notes:
		rs 2020-03-23: Generating PDF versions of these
			I've found that it definitely works better to use Firefox to create the PDFs for these,
			as the PDFs generated by Chromium-based browsers are not searchable and the font metrics
			are goofy when you go to select text (the selection highlight is vertically offset from
			the actual text).

			Printing options:
				Portrait
				US Letter
				[x] Ignore Scaling and Shrink to Fit Page Width
				[x] Print Background Colors
				[x] Print Background Images

			We are currently generating these with no headers, and the only footer entry is the
			center entry, set to "Page # of #"

			In order to get page headers and footers to match the text of the document, be sure to
			set Firefox's default fonts to match the document:
				Proportional: Sans Serif
				Serif: IBM Plex Sans (this one has to match, too; not sure why)
				Sans Serif: IBM Plex Sans

	*/

	// Function tq(): Replace quotation marks in strings with typographic quotes
	public string function tq(required string s) {
		var _s = arguments.s;
		var _n = 0;

		while (findNoCase('"', _s)) {
			_s = replaceNoCase(_s, '"', (_n++ % 2 ? '&rdquo;' : '&ldquo;' ), 'one');
		}

		return _s;
	}

	public string function smartNumberFormat(required any v, required string u) {
		var _s = '';
		var _v = Val(arguments.v);

		if (compareNoCase('%', arguments.u) == 0) {
			if ((_v != 0.) && (_v < 0.01)) {
				_s = '< 0.01';
			}
			else if ((_v != 100.) && (_v > 99.99)) {
				_s = '> 99.99';
			}
			else {
				_s = numberFormat(_v, '9,999.00');
			}
		}
		else {
			_s = numberFormat(_v);
		}

		return _s;
	}

	// Function dqs(): Generate the data quality summary markup for the provided object
	public string function dqs(required struct s) {
		var _s = '';

		if (structKeyExists(s, 'measures')) {
			// Figure out if any of the measures have notes:
			var _notes = s.measures.reduce(function(p, e) { return arguments.p || (structKeyExists(arguments.e, 'notes') ? true : false); }, false);

			// Table head:
			_s &= '<table><thead><tr><th>Quality Measure</th><th colspan="2">Value</th>' & (_notes ? '<th>Notes</th>' : '') & '</tr></thead><tbody>';

			// Row for each measure, with optional notes:
			for (var m in s.measures) {
				_s &= '<tr' & ((structKeyExists(m, 'showAsSummary') && m.showAsSummary) ? ' class="summary"' : '') & '><td>' & m.name & '</td><td class="value">' & smartNumberFormat(m.value, m.units) & '</td><td>' & m.units & '</td>';
				if (_notes) {
					_s &= structKeyExists(m, 'notes') ? '<td>' & tq(m.notes) & '</td>' : '<td />';
				}
				_s &= '</tr>';
			}

			// ... and close the table:
			_s &= '</tbody></table>';
		}

		// If the summary has notes, show them:
		if (structKeyExists(s, 'notes')) {
			_s &= '<p class="notes"><strong>Notes:</strong>&nbsp;' & tq(t.dataQualitySummary.notes) & '</p>';
		}

		return _s;
	}

	// Max. number of categories from the frequency distributions we will show (default to 5 unless over-ridden):
	_maxFDcat = structKeyExists(url, 'c') ? max(2, min(val(url.c), 999)) : 5;

	// JSON file to be processed:
	_p = listDeleteAt(cgi.path_Translated, listLen(cgi.path_Translated, '/'), '/') & '/' & url.f;
	_d = deserializeJSON(fileRead(_p));

	// Generate the content for all of the objects in the dataset:
	saveContent variable="c" {
		for (t in _d.objects) {
			writeOutput('<h3 class="object">Table: ' & t.name & '</h3>');
			writeOutput('<dl class="object">');

			if (structKeyExists(t, 'description')) {
				writeOutput('<dt>Description</dt><dd>' & tq(Len(t.description) ? t.description : '(none provided)') & '</dd>');
			}

			if (structKeyExists(t, 'count')) {
				writeOutput('<dt>Count</dt><dd>' & numberFormat(t.count) & ' rows/instances</dd>');
			}
			writeOutput('</dl>');

			if (structKeyExists(t, 'dataQualitySummary')) {
				writeOutput('<h4>Table Data Quality Summary</h4>');
				writeOutput(dqs(t.dataQualitySummary));
			}

			writeOutput('<h4>Attributes</h4>');
			writeOutput('<table><thead><tr><th>Name</th><th>Type</th><th>Units</th><th>Refers&nbsp;To</th><th>Description</th></tr></thead><tbody>');
			for (r in t.attributes) {
				writeOutput('<tr><td>' & r.name & '</td><td class="type">' & r.type & '</td>' & (structKeyExists(r, 'units') ? '<td>' & r.units & '</td>' : '<td />') & (structKeyExists(r, 'refersTo') ? '<td>' & r.refersTo & '</td>': '<td />') & (structKeyExists(r, 'description') ? '<td>' & tq(Len(r.description) ? r.description : '(none provided)') & '</td>' : '<td />') & '</tr>');
			}
			writeOutput('</tbody></table>');
			writeOutput('<h4>Data Quality Measures</h4>');
			writeOutput('<table><thead><tr><th>Applies&nbsp;To</th><th>Name</th><th>Value</th><th>Units</th><th colspan="3">Description</th></tr></thead><tbody>');

			nDQM = 0;

			if (structKeyExists(t, 'dataQuality')) {
				nM = 0;
				for (m in t.dataQuality) {
					// Format the value in a way that makes sense:
					_v = m.value;
					if (isValid('numeric', m.value)) {
						_v = (round(m.value) == m.value) ? numberFormat(m.value) : numberFormat(m.value, '9,9.000');
					}

					// Note: we only show the table name on the first measure
					writeOutput('<tr>' & (nM ? '<td />' : '<td>' & t.name  & '</td>') & '<td>' & m.name & '</td><td class="value">' & _v & '</td><td>' & m.units & '</td><td>' & tq(Len(m.description) ? m.description : '(none provided)') & '</td></tr>');
					nM++;
				}
				nDQM += nM;
			}
			for (r in t.attributes) {
				if (structKeyExists(r, 'dataQuality')) {
					nM = 0;
					for (m in r.dataQuality) {
						// Format the value in a way that makes sense:
						_v = m.value;
						if (isValid('numeric', m.value)) {
							_v = (round(m.value) == m.value) ? numberFormat(m.value) : numberFormat(m.value, '9,9.000');
						}

						// Note: we only show the table.attribute name on the first measure
						writeOutput('<tr>' & (nM ? '<td />' : '<td>' & t.name & '.' & r.name & '</td>') & '<td class="type">' & m.name & '</td><td class="value">' & _v & '</td><td>' & m.units & '</td><td colspan="3">' & (Len(m.description) ? m.description : '') & '</td></tr>');
						nM++;

						// Frequency distribution, if present:
						if (structKeyExists(m, 'frequencies')) {
							writeOutput('<tr><td /><td colspan="3">Distribution</td><td class="fd-header">Category</td><td class="fd-header">n</td><td class="fd-header">%</td></tr>');
							if (arrayLen(m.frequencies)) {
								nC = 0;
								for (c in m.frequencies) {
									writeOutput('<tr><td colspan="4" /><td>' & c.name & '</td>' & (structKeyExists(c, 'frequencyN') ? '<td class="value">' & numberFormat(c.frequencyN) & '</td>' : '<td />') & (structKeyExists(c, 'frequencyPercent') ? '<td class="value">' & numberFormat(c.frequencyPercent, '9.00') & '</td>' : '<td />') & '</tr>');
									nC++;

									if ((nC == _maxFDcat) && (nC < arrayLen(m.Frequencies))) {
										writeOutput('<tr><td colspan="4" /><td colspan="3">(' & numberFormat(arrayLen(m.frequencies) - nC) & ' additional categories not shown)</td></tr>');
										break;
									}
								}
							}
						}
					}
					nDQM += nM;
				}
			}

			// Deal with situations where we have no data quality metrics on this object:
			if (!nDQM) {
				writeOutput('<tr><td colspan="5">(none defined)</td></tr>');
			}

			writeOutput('</tbody></table>');
		}
	}
</cfscript>

<!--- Page header: --->
<cfsavecontent variable="h">
<cfoutput>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Livewire Data Platform: Data Dictionary -- #_d.name#</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,700|IBM+Plex+Sans+Condensed:400|IBM+Plex+Serif:400,700&display=swap">
<link rel="stylesheet" href="./_assets/livewire-dictionary.css">
</head>
<body>
<div class="section title-page">
<header><img src="./_assets/livewire-logo.png" /></header>
<h1>Livewire Data Platform: Data Dictionary</h1>
<h2>#tq(_d.name)#</h2>
<dl>
	<dt>Authors</dt><dd>#_d.authors#</dd>
	<dt>Modified</dt><dd>#listFirst(_d.modified, ' ')#</dd>
	<dt>Generated</dt><dd>#dateFormat(Now(), 'yyyy-MM-dd')#</dd>
</dl>
<!--- Need rest of stuff for title page? --->
</div>
<div class="section">
<h1>Livewire Data Platform: Data Dictionary</h1>
<h2>#tq(_d.name)#</h2>
<p class="description">#tq(Len(_d.description) ? _d.description : '(no description provided)')#</p>

<cfif structKeyExists(_d, 'dataQualitySummary')>
	<h3>Data Quality Summary</h3>
	#dqs(_d.dataQualitySummary)#
	<p class="see-also">For information on how the Livewire Data Platform project characterizes dataset quality, see the Livewire Data Platform's Frequently Asked Questions (<a href="https://livewire.energy.gov/faq">https://livewire.energy.gov/faq)</a>.</p>
</cfif>

</cfoutput>
</cfsavecontent>

<!--- Page footer: --->
<cfsavecontent variable="f">
</div> <!--- class="section" --->
</body>
</html>
</cfsavecontent>

<!--- Generate the full document: --->
<cfoutput>#h##c##f#</cfoutput>
<!---
<cfdump var="#cgi#" label="Scope CGI" expand="false" />
--->
